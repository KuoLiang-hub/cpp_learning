11.6 - Selection Sort:
	Swap smallest with current position.
	[5, 3, 1, 4, 8] =>
	[1, 3, 5, 4, 8] =>
	[1, 3, 4, 5, 8]
runtime: (N^2)/2, O(N^2)

	
11.9 - Insertion Sort:
	loop to swap the one next to current position. i=1, j=i-1 for outter loop.
i=1,j=0
	[5, 3, 1, 4, 8] =>
	[3, 5, 1, 4, 8] =>
i=2,
	j=12
	[3, 1, 5, 4, 8] =>
	j=0
	[1, 3, 5, 4, 8] =>
i=3
	j=2
	[1, 3, 4, 5, 8] =>
i=4
	j=3
	[1, 3, 4, 5, 8]
runtime : n(n-1)/2 , O(n^2)


11.12 - Shell sort
	i + gap value
	gap value determins how many sub lists. k = 2, means 2 lists.

11.15 quick sourt
	partition()
		runt time : O(N)
	
	quick_sort()

		quick case:
		runtime: O(N log(N))
		comparison: N * log2(N)
		eg. 1024 element, will have 1024 * log2(1024) = 10240 

		worst case: 
		level: N-1 
		runtime : (N+1)N/2 , O(N^2)
		quick sout function called: 1 + 2(N -1) = 2N - 1

11.18 Merge sort
	Runtime: O(N Log(N))
	recursive level : log2(N)


11.21 Bucket sort
	designed for arrays with non-negative numbers.
	bucket : (M + 1) / N values in each bucket
	eg. max 49, 10 bucket, (49 + 1) / 10 = 5 
	index = floor(number * N/(M + 1))
	eg. (71,11,99,7,14) into 5 buckets
	71 : floor(71 * 5/(99+1)) = 3
	99 : floor(99 * 5/(99+1)) = 4


11.22 Radix sort
	designed for integers
	10 buckets 0 - 9, could be based on 1's digit, 10's 100's....
	runtime:	O(N)
	space: O(N)

11.25 Overview of fast sorting algorithms
	